<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>src-ts/polytopes/polytopeTypes.js - Documentation</title><script src="scripts/prettify/prettify.js"></script><script src="scripts/prettify/lang-css.js"></script><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><link type="text/css" rel="stylesheet" href="styles/prettify.css"><link type="text/css" rel="stylesheet" href="styles/jsdoc.css"><script src="scripts/nav.js" defer="defer"></script><meta name="viewport" content="width=device-width,initial-scale=1"></head><body><input type="checkbox" id="nav-trigger" class="nav-trigger"> <label for="nav-trigger" class="navicon-button x"><div class="navicon"></div></label> <label for="nav-trigger" class="overlay"></label><nav><input type="text" id="nav-search" placeholder="Search"><h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/officialurl/miratope" target="_blank" class="menu-item" id="repository">Github repo</a></h2><h3>Classes</h3><ul><li><a href="AvlNode.html">AvlNode</a><ul class="methods"><li data-type="method" style="display:none"><a href="AvlNode.html#leftHeight">leftHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#leftHeight">leftHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkLeft">linkLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkLeft">linkLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkRight">linkRight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkRight">linkRight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rightHeight">rightHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rightHeight">rightHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateLeft">rotateLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateLeft">rotateLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateRight">rotateRight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateRight">rotateRight</a></li></ul></li><li></li><li><a href="AvlTree.html">AvlTree</a><ul class="methods"><li data-type="method" style="display:none"><a href="AvlTree.html#.getBalanceState">getBalanceState</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#.getBalanceState">getBalanceState</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#contains">contains</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#contains">contains</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#delete">delete</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#delete">delete</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximum">findMaximum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximum">findMaximum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximumNode">findMaximumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximumNode">findMaximumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimum">findMinimum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimum">findMinimum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimumNode">findMinimumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimumNode">findMinimumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#getNode">getNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#getNode">getNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#insert">insert</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#insert">insert</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#isEmpty">isEmpty</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#isEmpty">isEmpty</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#size">size</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#size">size</a></li></ul></li><li></li><li><a href="Caret.html">Caret</a><ul class="methods"><li data-type="method" style="display:none"><a href="Caret.html#advance">advance</a></li><li data-type="method" style="display:none"><a href="Caret.html#advance">advance</a></li><li data-type="method" style="display:none"><a href="Caret.html#getChar">getChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#getChar">getChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#increment">increment</a></li><li data-type="method" style="display:none"><a href="Caret.html#increment">increment</a></li><li data-type="method" style="display:none"><a href="Caret.html#readNumber">readNumber</a></li><li data-type="method" style="display:none"><a href="Caret.html#readNumber">readNumber</a></li><li data-type="method" style="display:none"><a href="Caret.html#readUntil">readUntil</a></li><li data-type="method" style="display:none"><a href="Caret.html#readUntil">readUntil</a></li><li data-type="method" style="display:none"><a href="Caret.html#readWord">readWord</a></li><li data-type="method" style="display:none"><a href="Caret.html#readWord">readWord</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToChar">skipToChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToChar">skipToChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToContent">skipToContent</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToContent">skipToContent</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToString">skipToString</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToString">skipToString</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToStringList">skipToStringList</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToStringList">skipToStringList</a></li><li data-type="method" style="display:none"><a href="Caret.html#throwError">throwError</a></li><li data-type="method" style="display:none"><a href="Caret.html#throwError">throwError</a></li></ul></li><li></li><li><a href="Point.html">Point</a><ul class="methods"><li data-type="method" style="display:none"><a href="Point.html#.padLeft">padLeft</a></li><li data-type="method" style="display:none"><a href="Point.html#.padLeft">padLeft</a></li><li data-type="method" style="display:none"><a href="Point.html#.padRight">padRight</a></li><li data-type="method" style="display:none"><a href="Point.html#.padRight">padRight</a></li><li data-type="method" style="display:none"><a href="Point.html#.product">product</a></li><li data-type="method" style="display:none"><a href="Point.html#.product">product</a></li><li data-type="method" style="display:none"><a href="Point.html#add">add</a></li><li data-type="method" style="display:none"><a href="Point.html#add">add</a></li><li data-type="method" style="display:none"><a href="Point.html#addCoordinate">addCoordinate</a></li><li data-type="method" style="display:none"><a href="Point.html#addCoordinate">addCoordinate</a></li><li data-type="method" style="display:none"><a href="Point.html#clone">clone</a></li><li data-type="method" style="display:none"><a href="Point.html#clone">clone</a></li><li data-type="method" style="display:none"><a href="Point.html#dimensions">dimensions</a></li><li data-type="method" style="display:none"><a href="Point.html#dimensions">dimensions</a></li><li data-type="method" style="display:none"><a href="Point.html#project">project</a></li><li data-type="method" style="display:none"><a href="Point.html#project">project</a></li><li data-type="method" style="display:none"><a href="Point.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="Point.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="Point.html#subtract">subtract</a></li><li data-type="method" style="display:none"><a href="Point.html#subtract">subtract</a></li></ul></li><li></li><li><a href="PolytopeC.html">PolytopeC</a><ul class="methods"><li data-type="method" style="display:none"><a href="PolytopeC.html#faceToVertices">faceToVertices</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#faceToVertices">faceToVertices</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#gravicenter">gravicenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#gravicenter">gravicenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#recenter">recenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#recenter">recenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#setSpaceDimensions">setSpaceDimensions</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#setSpaceDimensions">setSpaceDimensions</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#toPolytopeC">toPolytopeC</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#toPolytopeC">toPolytopeC</a></li></ul></li><li></li><li><a href="Scene.html">Scene</a><ul class="methods"><li data-type="method" style="display:none"><a href="Scene.html#add">add</a></li><li data-type="method" style="display:none"><a href="Scene.html#add">add</a></li></ul></li><li></li><li><a href="SweeplineEdge.html">SweeplineEdge</a><ul class="methods"><li data-type="method" style="display:none"><a href="SweeplineEdge.html#getId">getId</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#getId">getId</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#rightVertex">rightVertex</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#rightVertex">rightVertex</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#updateRedirectTable">updateRedirectTable</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#updateRedirectTable">updateRedirectTable</a></li></ul></li><li></li></ul><h3>Namespaces</h3><ul><li><a href="BalanceState.html">BalanceState</a></li><li></li><li><a href="ConstructionNodeType.html">ConstructionNodeType</a></li><li></li><li><a href="Space.html">Space</a><ul class="methods"><li data-type="method" style="display:none"><a href="Space.html#.area">area</a></li><li data-type="method" style="display:none"><a href="Space.html#.area">area</a></li><li data-type="method" style="display:none"><a href="Space.html#.distance">distance</a></li><li data-type="method" style="display:none"><a href="Space.html#.distance">distance</a></li><li data-type="method" style="display:none"><a href="Space.html#.distanceSq">distanceSq</a></li><li data-type="method" style="display:none"><a href="Space.html#.distanceSq">distanceSq</a></li><li data-type="method" style="display:none"><a href="Space.html#.intersect">intersect</a></li><li data-type="method" style="display:none"><a href="Space.html#.intersect">intersect</a></li><li data-type="method" style="display:none"><a href="Space.html#.sameSlope">sameSlope</a></li><li data-type="method" style="display:none"><a href="Space.html#.sameSlope">sameSlope</a></li></ul></li><li></li><li><a href="Translation.html">Translation</a><ul class="methods"><li data-type="method" style="display:none"><a href="Translation.html#.addAdjective">addAdjective</a></li><li data-type="method" style="display:none"><a href="Translation.html#.addAdjective">addAdjective</a></li><li data-type="method" style="display:none"><a href="Translation.html#.elementName">elementName</a></li><li data-type="method" style="display:none"><a href="Translation.html#.elementName">elementName</a></li><li data-type="method" style="display:none"><a href="Translation.html#.greekPrefix">greekPrefix</a></li><li data-type="method" style="display:none"><a href="Translation.html#.greekPrefix">greekPrefix</a></li></ul></li><li></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-dependencies.html">How to update Miratope's dependencies?</a></li><li><a href="tutorial-translation_.html">How to translate Miratope?</a></li></ul><h3>Global</h3><ul><li><a href="global.html#BalanceState%255Bundefined%255D">BalanceState[undefined]</a></li><li><a href="global.html#CNType%255Bundefined%255D">CNType[undefined]</a></li></ul></nav><div id="main"><h1 class="page-title">src-ts/polytopes/polytopeTypes.js</h1><section><article><pre class="prettyprint source linenums"><code>"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolytopeS = exports.PolytopeC = exports.PolytopeB = exports.PolytopeType = void 0;
const constructionNode_1 = require("../data structures/constructionNode");
const linkedListNode_1 = require("../data structures/linkedListNode");
const point_1 = require("../geometry/point");
const flag_1 = require("../data structures/flag");
var PolytopeType;
(function (PolytopeType) {
    PolytopeType[PolytopeType["C"] = 0] = "C";
    PolytopeType[PolytopeType["S"] = 1] = "S";
})(PolytopeType = exports.PolytopeType || (exports.PolytopeType = {}));
class PolytopeB {
    getName() {
        return this.construction.getName();
    }
    //Declared in off.ts.
    saveAsOFF(_options) {
        _options;
        throw new Error("saveAsOFF called before implementation!");
    }
    //Declared in ggb.ts.
    saveAsGGB(_wireframe) {
        _wireframe;
        throw new Error("saveAsGGB called before implementation!");
    }
    //Declared in polytopeBuild.ts.
    extrudeToPyramid(_apex) {
        _apex;
        throw new Error("extrudeToPyramid called before implementation!");
    }
    //Declared in polytopeProducts.ts.
    extrudeToPrism(_height) {
        _height;
        throw new Error("extrudeToPrism called before implementation!");
    }
    //Declared in polytopeCD.ts.
    polytopeToGraph() {
        throw new Error("polytopeToGraph called before implementation!");
    }
    //Declared in render.ts.
    renderTo(_scene) {
        _scene;
        throw new Error("renderTo called before implementation!");
    }
}
exports.PolytopeB = PolytopeB;
class PolytopeC extends PolytopeB {
    /**
     * The constructor for the PolytopeC class.
     * @constructor
     * @param {ElementList} elementList The polytope's element list.
     * @param {ConstructionNode} constructionRoot The constructionNode
     * representing how the polytope was built.
     * @classDesc Represents a polytope as a list of elements, in ascending order
     * of dimensions,
     * similarly (but not identically) to an OFF file.
     * Subelements are stored as indices.
     * All points are assumed to be of the same dimension.
     */
    constructor(elementList, constructionRoot) {
        super();
        if (!constructionRoot)
            //The construction defaults to just the polytope itself.
            constructionRoot = new constructionNode_1.CNPlain([
                elementList[elementList.length - 2].length,
                elementList.length - 1,
            ]);
        this.construction = constructionRoot;
        this.dimensions = elementList.length - 1; //The rank of the polytope.
        this.elementList = elementList;
        this.type = PolytopeType.C;
        if (this.elementList[0])
            this.spaceDimensions = this.elementList[0][0].dimensions();
        else
            this.spaceDimensions = -1; //The almighty nullitope (aka nothing)
    }
    setConstruction(construction) {
        this.construction = construction;
        construction.polytope = this;
    }
    /**
     * Scales a polytope up or down.
     * @param {number} r The scaling factor.
     * @returns {Polytope} The scaled polytope.
     */
    scale(r) {
        if (!this.elementList[0])
            return this;
        for (let i = 0; i &lt; this.elementList[0].length; i++)
            this.elementList[0][i].scale(r);
        return this;
    }
    /**
     * Calculates the centroid of a polytope.
     * @returns {Point} The centroid of the polytope.
     */
    gravicenter() {
        if (!this.elementList[0])
            return new point_1.Point(0);
        const d = this.spaceDimensions;
        const res = [];
        for (let i = 0; i &lt; d; i++)
            res.push(0);
        for (let i = 0; i &lt; this.elementList[0].length; i++)
            for (let j = 0; j &lt; d; j++)
                res[j] += this.elementList[0][i].coordinates[j];
        for (let i = 0; i &lt; d; i++)
            res[i] /= this.elementList[0].length;
        return new point_1.Point(res);
    }
    circumradius() {
        const els = this.toPolytopeC().elementList;
        return els[0] ? els[0][0].magnitude() : 0;
    }
    move(P, mult) {
        if (!this.elementList[0])
            return this;
        const Q = P.clone().scale(mult);
        for (let i = 0; i &lt; this.elementList[0].length; i++)
            this.elementList[0][i].add(Q);
        return this;
    }
    /**
     * Makes every vertex have a set number of coordinates either by adding zeros
     * or removing numbers.
     * @param {number} dim The new number of coordinates for each vertex.
     */
    setSpaceDimensions(dim) {
        if (!this.elementList[0])
            return;
        for (let i = 0; i &lt; this.elementList[0].length; i++) {
            if (this.elementList[0][i].coordinates.length > dim)
                this.elementList[0][i].coordinates = this.elementList[0][i].coordinates.slice(0, dim);
            else if (this.elementList[0][i].coordinates.length &lt; dim)
                for (let j = 0; j &lt; dim - this.elementList[0][i].coordinates.length; j++)
                    this.elementList[0][i].coordinates.push(0);
        }
        this.spaceDimensions = dim;
    }
    /**
     * Converts the edge representation of the i-th face to an ordered array of
     * vertices.
     * @param {number} i The selected face.
     * @returns {number[]} An array with the indices of the vertices of the i-th
     * face in order.
     */
    faceToVertices(i) {
        if (!this.elementList[2] || !this.elementList[2][i])
            throw RangeError("The polytope does not have that many 2-faces!");
        //Enumerates the vertices in order.
        //A doubly linked list does the job easily.
        const vertexDLL = [];
        for (let j = 0; j &lt; this.elementList[2][i].length; j++) {
            const edge = this.elementList[1][this.elementList[2][i][j]];
            if (vertexDLL[edge[0]] === undefined)
                vertexDLL[edge[0]] = new linkedListNode_1.LinkedListNode(edge[0]);
            if (vertexDLL[edge[1]] === undefined)
                vertexDLL[edge[1]] = new linkedListNode_1.LinkedListNode(edge[1]);
            vertexDLL[edge[0]].linkTo(vertexDLL[edge[1]]);
        }
        //Cycle of vertex indices.
        //"this.elementList[1][this.elementList[2][i][0]][0]" is just some vertex
        //index.
        return vertexDLL[this.elementList[1][this.elementList[2][i][0]][0]].getCycle();
    }
    /**
     * Places the gravicenter of the polytope at the origin.
     * @returns {PolytopeC} The recentered polytope.
     */
    recenter() {
        return this.move(this.gravicenter(), -1);
    }
    /**
     * Ensures that we can always correctly call toPolytopeC on a polytope.
     * @returns {PolytopeC} The polytope, unchanged.
     */
    toPolytopeC() {
        return this;
    }
}
exports.PolytopeC = PolytopeC;
//Represents a polytope in a way that takes advantage of symmetry
//Obviously, this requires a representation of the symmetry group.
//The other components are a description of how the flags (tuples of
//vertex/edge/face...) within a single domain connect to each other under
//"change vertex/edge/..." operations, matrices describing how the symmetry
//group affects the physical representation of the polytope, and positions of
//each class of vertices.
//In this implementation the symmetry group and its physical effects are
//bundled.
class PolytopeS extends PolytopeB {
    constructor(symmetries, flagClasses, vertices, dimensions) {
        super();
        this.symmetries = symmetries;
        this.flagClasses = flagClasses;
        this.vertices = vertices;
        this.dimensions = dimensions;
        this.identitySimplifier = {};
        this.spaceDimensions = vertices[0].dimensions();
        this.type = PolytopeType.S;
        this.construction = new constructionNode_1.CNName("temp");
    }
    //The gravicenter is the gravicenter of the original vertices,
    //weighted by the inverse of the number of domains each vertex appears in,
    //projected onto the intersection of the eigenspaces of the generators
    //with eigenvalues 1.
    gravicenter() {
        throw new Error("PolytopeS.gravicenter is not yet implemented");
    }
    scale(r) {
        for (let i = 0; i &lt; this.vertices.length; i++)
            this.vertices[i].scale(r);
        return this;
    }
    move(_P) {
        _P;
        throw new Error("PolytopeS move not yet implemented!");
    }
    circumradius() {
        throw new Error("PolytopeS circumradius not yet implemented!");
    }
    //Apply a flag-change operation to a flag.
    //Operators numbered from vertex to facet.
    moveFlag(flag, generator) {
        const flagClass = flag.number;
        const flagDomain = flag.element;
        const effects = this.flagClasses[generator][flagClass];
        const newFlagClass = effects[0];
        let newFlagDomain = flagDomain;
        for (let i = 0; i &lt; effects[1].length; i++)
            newFlagDomain = this.symmetries.multiply(newFlagDomain, this.symmetries.generators[effects[1][i]]);
        return new flag_1.Flag(newFlagClass, newFlagDomain);
    }
    compareFlags(flag1, flag2) {
        if (flag1.number &lt; flag2.number)
            return -1;
        if (flag1.number > flag2.number)
            return 1;
        return this.symmetries.compare(flag1.element, flag2.element);
    }
    //Utility function for toPolytopeC.
    //Modifies a simplifier to use another generator.
    //Almost identical to the merge function but I don't really care rn.
    extendSimplifier(simplifier, generator) {
        const newSimplifier = {};
        for (const i in simplifier)
            newSimplifier[i] = simplifier[i];
        for (const i in simplifier) {
            let oldLeftElem = new flag_1.Flag(0, this.symmetries.identity());
            let leftElem = this.identitySimplifier[i];
            let oldRightElem = this.moveFlag(oldLeftElem, generator);
            let rightElem = this.moveFlag(leftElem, generator);
            while (oldLeftElem.number != leftElem.number ||
                !this.symmetries.equal(oldLeftElem.element, leftElem.element)) {
                oldLeftElem = leftElem;
                leftElem = newSimplifier[leftElem.toString()];
                //console.log("upd left", ""+oldLeftElem, ""+leftElem);
            }
            while (oldRightElem.number != rightElem.number ||
                !this.symmetries.equal(oldRightElem.element, rightElem.element)) {
                oldRightElem = rightElem;
                rightElem = newSimplifier[rightElem.toString()];
                //console.log("upd right", ""+oldRightElem, ""+rightElem);
            }
            const order = this.compareFlags(leftElem, rightElem);
            //console.log("order", ""+leftElem, ""+rightElem, order);
            if (order === 0)
                continue;
            if (order === -1)
                newSimplifier[rightElem.toString()] = leftElem;
            if (order === 1)
                newSimplifier[leftElem.toString()] = rightElem;
        }
        const betterSimplifier = {};
        for (const i in newSimplifier) {
            let oldElem = new flag_1.Flag(0, this.symmetries.identity());
            let elem = newSimplifier[i];
            while (this.compareFlags(oldElem, elem)) {
                oldElem = elem;
                elem = newSimplifier[elem.toString()];
            }
            betterSimplifier[i] = elem;
        }
        return betterSimplifier;
    }
    //Utility function for toPolytopeC.
    //Merges two simplifiers.
    mergeSimplifiers(simplifier1, simplifier2) {
        const newSimplifier = {};
        for (const i in simplifier1)
            newSimplifier[i] = simplifier1[i];
        for (const i in simplifier1) {
            let oldLeftElem = new flag_1.Flag(0, this.symmetries.identity());
            let leftElem = simplifier1[i];
            let oldRightElem = new flag_1.Flag(0, this.symmetries.identity());
            let rightElem = simplifier2[i];
            while (oldLeftElem.number != leftElem.number ||
                !this.symmetries.equal(oldLeftElem.element, leftElem.element)) {
                oldLeftElem = leftElem;
                leftElem = newSimplifier[leftElem.toString()];
            }
            while (oldRightElem.number != rightElem.number ||
                !this.symmetries.equal(oldRightElem.element, rightElem.element)) {
                oldRightElem = rightElem;
                rightElem = newSimplifier[rightElem.toString()];
            }
            const order = this.compareFlags(leftElem, rightElem);
            if (order === 0)
                continue;
            if (order === -1)
                newSimplifier[rightElem.toString()] = leftElem;
            if (order === 1)
                newSimplifier[leftElem.toString()] = rightElem;
        }
        const betterSimplifier = {};
        for (const i in newSimplifier) {
            let oldElem = new flag_1.Flag(0, this.symmetries.identity());
            let elem = newSimplifier[i];
            while (this.compareFlags(oldElem, elem)) {
                oldElem = elem;
                elem = newSimplifier[elem.toString()];
            }
            betterSimplifier[i] = elem;
        }
        return betterSimplifier;
    }
    //Count a simplifier's cosets. Not needed except for debugging.
    simplifierCosets(simplifier) {
        let count = 0;
        for (const i in simplifier)
            if (i === simplifier[i].toString())
                count++;
        return count;
    }
    //This is basically the algorithm from the Gr√ºnbaumian thing,
    //but modified to work for higher dimensions and calculate incidences.
    toPolytopeC() {
        const maxDomains = 500; //Change to Infinity if you dare
        const domains = this.symmetries.enumerateElements(maxDomains);
        //Maps each flag to itself. Used as a base for the later simplifiers.
        const identitySimplifier = {};
        for (let i = 0; i &lt; domains.length; i++) {
            for (let j = 0; j &lt; this.flagClasses[0].length; j++) {
                identitySimplifier[j + "," + domains[i]] = new flag_1.Flag(j, domains[i]);
            }
        }
        //Used in the simplifier operations to convert from stringified flags to
        //flags.
        this.identitySimplifier = identitySimplifier;
        //Maps each flag to a representative flag of its subwhatever
        //generated by the first n change vertex/face/etc operations.
        const ascendingSimplifiers = [identitySimplifier];
        console.log("Ascending simplifiers");
        for (let i = 0; i &lt; this.dimensions; i++) {
            const lastSimplifier = ascendingSimplifiers[ascendingSimplifiers.length - 1];
            console.log(lastSimplifier, this.simplifierCosets(lastSimplifier));
            ascendingSimplifiers.push(this.extendSimplifier(lastSimplifier, i));
        }
        //Maps each flag to a representative flag of its subwhatever
        //generated by the first n change facet/ridge/etc operations.
        const descendingSimplifiers = [identitySimplifier];
        console.log("Descending simplifiers");
        for (let i = 0; i &lt; this.dimensions; i++) {
            const lastSimplifier = descendingSimplifiers[descendingSimplifiers.length - 1];
            console.log(lastSimplifier, this.simplifierCosets(lastSimplifier));
            descendingSimplifiers.push(this.extendSimplifier(lastSimplifier, this.dimensions - (i + 1)));
        }
        //Maps each flag to a representative flag of the subwhatever
        //fixing that flag's vertex/edge/etc.
        const elementSimplifiers = [];
        console.log("Element simplifiers");
        for (let i = 0; i &lt; this.dimensions; i++) {
            const simplifier = this.mergeSimplifiers(ascendingSimplifiers[i], descendingSimplifiers[this.dimensions - (i + 1)]);
            console.log(simplifier, this.simplifierCosets(simplifier));
            elementSimplifiers.push(simplifier);
        }
        elementSimplifiers.push(ascendingSimplifiers[this.dimensions]);
        //Maps each flag to a representative flag of the subwhatever
        //fixing that flag's vertex-edge/edge-face/etc pair.
        const intersectionSimplifiers = [];
        console.log("Intersection simplifiers");
        for (let i = 0; i &lt; this.dimensions - 1; i++) {
            const simplifier = this.mergeSimplifiers(ascendingSimplifiers[i], descendingSimplifiers[this.dimensions - (i + 2)]);
            console.log(simplifier, this.simplifierCosets(simplifier));
            intersectionSimplifiers.push(simplifier);
        }
        intersectionSimplifiers.push(ascendingSimplifiers[this.dimensions - 1]);
        //Vertices are inherently different from other elements, so compute them
        //separately.
        const vertices = [];
        for (let i = 0; i &lt; domains.length; i++) {
            for (let j = 0; j &lt; this.flagClasses[0].length; j++) {
                const flag = new flag_1.Flag(j, domains[i]);
                //Skip flags that aren't vertex representatives
                if (this.compareFlags(flag, elementSimplifiers[0][flag.toString()])) {
                    continue;
                }
                const vertex = flag.element[1].movePoint(this.vertices[flag.number]);
                vertices.push(vertex);
            }
        }
        console.log("Vertices");
        console.log(vertices);
        //Map representatives to IDs.
        const locations = [];
        const locationsLengths = [];
        for (let i = 0; i &lt; this.dimensions + 1; i++) {
            const locationsRow = {};
            let nextID = 0;
            for (let j = 0; j &lt; domains.length; j++) {
                for (let k = 0; k &lt; this.flagClasses[0].length; k++) {
                    const flag = new flag_1.Flag(k, domains[j]);
                    if (this.compareFlags(flag, elementSimplifiers[i][flag.toString()])) {
                        continue;
                    }
                    locationsRow[flag.toString()] = nextID++;
                }
            }
            locations.push(locationsRow);
            locationsLengths.push(nextID);
        }
        console.log("Locations");
        console.log(locations, locationsLengths);
        console.log("Higher elements");
        const elems = [vertices];
        for (let i = 1; i &lt; this.dimensions + 1; i++) {
            //TODO rename this to something better
            const someElems = [];
            for (let j = 0; j &lt; locationsLengths[i]; j++)
                someElems.push([]);
            for (let j = 0; j &lt; domains.length; j++) {
                for (let k = 0; k &lt; this.flagClasses[0].length; k++) {
                    const flag = new flag_1.Flag(k, domains[j]);
                    if (this.compareFlags(flag, intersectionSimplifiers[i - 1][flag.toString()])) {
                        continue;
                    }
                    const leftFlag = elementSimplifiers[i - 1][flag.toString()];
                    const rightFlag = elementSimplifiers[i][flag.toString()];
                    const leftID = locations[i - 1][leftFlag.toString()];
                    const rightID = locations[i][rightFlag.toString()];
                    someElems[rightID].push(leftID);
                }
            }
            console.log(someElems);
            elems.push(someElems);
        }
        return new PolytopeC(elems);
    }
}
exports.PolytopeS = PolytopeS;
//# sourceMappingURL=polytopeTypes.js.map</code></pre></article></section></div><br class="clear"><footer>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Sat Dec 26 2020 20:10:58 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.</footer><script>prettyPrint()</script><script src="scripts/polyfill.js"></script><script src="scripts/linenumber.js"></script><script src="scripts/search.js" defer="defer"></script><script src="scripts/collapse.js" defer="defer"></script></body></html>